[["index.html", "Analisis para Nacidos Vivos en el hospital Manuel Uribe Angel Chapter 1 Proyecto 1.1 Descripción de los datos. 1.2 Vista rapida de datos.", " Analisis para Nacidos Vivos en el hospital Manuel Uribe Angel David Cardenas, Aldair Blanco, Gustavo Ruiz 2024-05-21 Chapter 1 Proyecto Este proyecto se enfoca en el análisis del patrón de la información publicada para los “Nacidos Vivos en el Hospital Manuel Uribe Ángel” en Colombia. Para ello, implementaremos el conjunto de datos obtenido de fuentes abiertas del gobierno colombiano. Nuestro objetivo primordial radica en llevar a cabo un análisis descriptivo exhaustivo de estos datos, con el propósito de identificar y comprender los patrones subyacentes presentes en las series temporales relacionadas con los nacimientos en este hospital. A través de un enfoque metodológico riguroso, nos adentraremos en la exploración detallada de cada aspecto de los datos. Nos comprometemos a aplicar técnicas analíticas avanzadas para detectar y evaluar tendencias, variaciones estacionales y posibles correlaciones entre los diferentes atributos registrados. Este análisis no solo busca comprender la distribución temporal de los nacimientos, sino también examinar cualquier fluctuación significativa que pueda influir en la dinámica de la salud materna en la región. Al implementar este conjunto de datos, aspiramos a no solo generar conocimiento sobre los patrones de nacimientos en el Hospital Manuel Uribe Ángel, sino también a proporcionar información valiosa para informar futuras investigaciones y políticas de salud pública. Este proyecto representa un esfuerzo centrado en la obtención de insights precisos y prácticos a partir de datos concretos, con el objetivo último de contribuir al avance del conocimiento en el campo de la salud materna y la atención médica en Colombia. 1.1 Descripción de los datos. Descripción Conjunto de datos con los nacimientos reportados por el Hospital Manuel Uribe Ángel, con una cohorte desde el 2018. Fuente de información Datos abiertos colombia: https://www.datos.gov.co/Estad-sticas-Nacionales/Nacidos-Vivos-en-Hospital-Manuel-Uribe-Angel/udqu-ifxr/about_data Fecha de creación 8 de octubre de 2019 Actualizado 26 de marzo de 2024 Suministró los datos Hospital Manuel Uribe Angel Propietario de conjunto de datos E.S.E. Hospital Manuel Uribe Ángel Nombre de la Entidad Hospital Manuel Uribe Ángel Sector Salud y Protección Social Departamento Antioquia Municipio Envigado URL Normativa https://www.minsalud.gov.co/sites/rid/Lists/BibliotecaDigital/RIDE/DE/DIJ/Decreto-1171-de-1997.pdf 1.2 Vista rapida de datos. Table 1.1: Conjunto de datos. DEPARTAMENTO MUNICIPIO AREA.NACIMIENTO SEXO PESO..Gramos. TALLA..Centímetros. FECHA.NACIMIENTO TIEMPO.DE.GESTACIÓN NÚMERO.CONSULTAS.PRENATALES TIPO.PARTO MULTIPLICIDAD.EMBARAZO PERTENENCIA.ÉTNICA GRUPO.INDIGENA EDAD.MADRE RÉGIMEN.SEGURIDAD NOMBRE.ADMINISTRADORA EDAD.PADRE NIVEL.EDUCATIVO.PADRE DEPARTAMENTO.EXPEDICIÓN MUNICIPIO.EXPEDICIÓN ESTADO.CONYUGAL.DE.LA.MADRE NIVEL.EDUCATIVO.DE.LA.MADRE NUMERO.DE.HIJOS.NACIDOS.VIVOS NUMERO.DE.EMBARAZOS AREA.DE.RESIDENCIA PAÍS.DE.RESIDENCIA DEPARTAMENTO.RESIDENCIA MUNICIPIO.RESIDENCIA LONGITUD LATITUD GEOREFERENCIA.RESIDENCIA ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCULINO 2085 45 05/06/2022 12:00:00 AM 37 8 ESPONTÁNEO SIMPLE NINGUNO DE LOS ANTERIORES 28 CONTRIBUTIVO EPS SURA 24 MEDIA ACADÉMICA O CLÁSICA ANTIOQUIA ENVIGADO NO ESTÁ CASADA Y LLEVA DOS AÑOS O MÁS VIVIENDO CON SU PAREJA BÁSICA SECUNDARIA 4 5 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA ITAGÜÍ -75.6143587142 6.16959762893 POINT (-75.6143587142 6.16959762893) ANTIOQUIA ENVIGADO CABECERA MUNICIPAL FEMENINO 3000 47 05/06/2022 12:00:00 AM 37 5 ESPONTÁNEO SIMPLE NINGUNO DE LOS ANTERIORES 33 CONTRIBUTIVO EPS SURA 29 MEDIA ACADÉMICA O CLÁSICA ANTIOQUIA ENVIGADO NO ESTÁ CASADA Y LLEVA MENOS DE DOS AÑOS VIVIENDO CON SU PAREJA PROFESIONAL 2 2 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA ENVIGADO -75.5830101409 6.16700455162 POINT (-75.5830101409 6.16700455162) ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCULINO 2905 50 05/07/2022 12:00:00 AM 39 8 ESPONTÁNEO SIMPLE NINGUNO DE LOS ANTERIORES 25 SUBSIDIADO NUEVA EPS S.A. 21 MEDIA ACADÉMICA O CLÁSICA ANTIOQUIA ENVIGADO NO ESTÁ CASADA Y LLEVA MENOS DE DOS AÑOS VIVIENDO CON SU PAREJA MEDIA ACADÉMICA O CLÁSICA 1 1 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA LA ESTRELLA -75.6451903823 6.15841974028 POINT (-75.6451903823 6.15841974028) ANTIOQUIA ENVIGADO CABECERA MUNICIPAL FEMENINO 3700 50 05/07/2022 12:00:00 AM 40 6 ESPONTÁNEO SIMPLE NINGUNO DE LOS ANTERIORES 39 CONTRIBUTIVO EPS SURA 32 TECNOLÓGICA ANTIOQUIA ENVIGADO NO ESTÁ CASADA Y LLEVA DOS AÑOS O MÁS VIVIENDO CON SU PAREJA TÉCNICA PROFESIONAL 1 1 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA ENVIGADO -75.5830101409 6.16700455162 POINT (-75.5830101409 6.16700455162) ANTIOQUIA ENVIGADO CABECERA MUNICIPAL FEMENINO 3130 49 05/07/2022 12:00:00 AM 39 12 ESPONTÁNEO SIMPLE NINGUNO DE LOS ANTERIORES 32 SUBSIDIADO SAVIA SALUD E.P.S. 37 SIN INFORMACIÓN ANTIOQUIA ENVIGADO ESTÁ CASADA MEDIA ACADÉMICA O CLÁSICA 2 2 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA ITAGÜÍ -75.6143587142 6.16959762893 POINT (-75.6143587142 6.16959762893) ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCULINO 3830 54 10/01/2021 12:00:00 AM 40 7 INSTRUMENTADO SIMPLE NINGUNO DE LOS ANTERIORES 23 SUBSIDIADO SAVIA SALUD E.P.S. 28 MEDIA ACADÉMICA O CLÁSICA ANTIOQUIA ENVIGADO NO ESTÁ CASADA Y LLEVA DOS AÑOS O MÁS VIVIENDO CON SU PAREJA TÉCNICA PROFESIONAL 1 1 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA SABANETA -75.6155852932 6.15097018093 POINT (-75.6155852932 6.15097018093) ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCULINO 2865 50 10/01/2021 12:00:00 AM 39 8 ESPONTÁNEO SIMPLE NINGUNO DE LOS ANTERIORES 30 CONTRIBUTIVO EPS SURA 25 MEDIA ACADÉMICA O CLÁSICA ANTIOQUIA ENVIGADO ESTÁ CASADA PROFESIONAL 1 1 CABECERA MUNICIPAL COLOMBIA ANTIOQUIA MEDELLÍN -75.581713332 6.246715564 POINT (-75.581713332 6.246715564) "],["Justificacion..html", "Chapter 2 Justificacion.", " Chapter 2 Justificacion. Este proyecto se centra en el análisis del patrón de la información publicada sobre los “Nacidos Vivos en el Hospital Manuel Uribe Ángel” en Colombia. Para ello, utilizaremos el conjunto de datos obtenido de fuentes gubernamentales abiertas de Colombia. Nuestro objetivo principal es realizar un análisis descriptivo exhaustivo de estos datos para identificar y comprender los patrones subyacentes presentes en las series temporales relacionadas con los nacimientos en este hospital. El propósito de este análisis es generar un pronóstico preciso sobre los futuros nacidos vivos en el hospital. Este pronóstico será fundamental para que el hospital se prepare y se abastezca de los instrumentos médicos necesarios para la atención de los recién nacidos, y también para gestionar adecuadamente el personal médico necesario. A través de un enfoque metodológico riguroso, nos adentraremos en la exploración detallada de cada aspecto de los datos. Nos comprometemos a aplicar técnicas analíticas avanzadas para detectar y evaluar tendencias, variaciones estacionales y posibles correlaciones entre los diferentes atributos registrados. Este análisis no solo busca comprender la distribución temporal de los nacimientos, sino también examinar cualquier fluctuación significativa que pueda influir en la dinámica de la salud materna en la región. Al implementar este conjunto de datos, aspiramos a no solo generar conocimiento sobre los patrones de nacimientos en el Hospital Manuel Uribe Ángel, sino también a proporcionar información valiosa para informar futuras investigaciones y políticas de salud pública. Este proyecto representa un esfuerzo centrado en la obtención de insights precisos y prácticos a partir de datos concretos, con el objetivo último de contribuir al avance del conocimiento en el campo de la salud materna y la atención médica en Colombia. Además del pronóstico, este análisis proporcionará información valiosa para la toma de decisiones estratégicas en el hospital, como la planificación de recursos humanos y materiales, la implementación de políticas de salud materno-infantil y la mejora continua de la calidad de la atención médica. "],["iDescomposicion.html", "Chapter 3 Descomposicion", " Chapter 3 Descomposicion La descomposición de series temporales es una técnica utilizada en el análisis de series temporales para descomponer una serie temporal en sus componentes basicos constituyentes, con el objetivo de entender mejor la estructura y los patrones subyacentes en los datos. Los componentes básicos de una serie temporal que pueden ser descompuestos son: Tendencia: Es la dirección general en la que los datos están cambiando con el tiempo. Puede ser ascendente, descendente o seguir un patrón más complejo. Estacionalidad: Son variaciones periódicas o cíclicas en los datos que se repiten en intervalos fijos de tiempo, como diarios, semanales, mensuales o anuales. Estas variaciones están asociadas con factores estacionales, como las estaciones del año o eventos recurrentes. Ciclo: Son variaciones que no siguen un patrón estacional específico y pueden ser de más largo plazo que las variaciones estacionales. Los ciclos pueden estar asociados con fluctuaciones económicas u otros fenómenos que se repiten en intervalos irregulares. Componente aleatorio o residual: Es la parte de la serie temporal que no puede ser explicada por la tendencia, la estacionalidad o el ciclo. Representa la variabilidad aleatoria o el ruido en los datos. Preparación de los datos Este código carga datos de nacimientos y los agrupa para calcular el número total de nacidos vivos por fecha teniendo en cuenta los partos dobles o simples. library(dplyr) ## Warning: package &#39;dplyr&#39; was built under R version 4.2.3 ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union DatosNacidos &lt;- read.csv(file = &quot;data/Nacidos_Vivos_en_Hospital_Manuel_Uribe_Angel_20240418.csv&quot;) DatosNacidos$FECHA &lt;- substr(DatosNacidos$FECHA,1,10) DatosNacidos$FECHA &lt;- as.Date(DatosNacidos$FECHA, format = &quot;%m/%d/%Y&quot;) agrupnacidos &lt;- DatosNacidos %&gt;% group_by(FECHA, MULTIPLICIDAD.EMBARAZO) %&gt;% summarize(NumeroPartos = n(), .groups = &#39;drop&#39;) agrupnacidos$NumeroNacidos &lt;- ifelse(agrupnacidos$MULTIPLICIDAD.EMBARAZO == &quot;DOBLE&quot;,agrupnacidos$NumeroPartos*2,agrupnacidos$NumeroPartos) agrupnacidos_2 &lt;- agrupnacidos %&gt;% group_by(FECHA) %&gt;% summarize(NumeroNacidos=sum(NumeroNacidos), .groups = &#39;drop&#39;) dfdesc &lt;- agrupnacidos_2 print(dfdesc) ## # A tibble: 1,976 × 2 ## FECHA NumeroNacidos ## &lt;date&gt; &lt;dbl&gt; ## 1 2018-01-01 10 ## 2 2018-01-02 10 ## 3 2018-01-03 6 ## 4 2018-01-04 7 ## 5 2018-01-05 14 ## 6 2018-01-06 10 ## 7 2018-01-07 11 ## 8 2018-01-08 6 ## 9 2018-01-09 7 ## 10 2018-01-10 11 ## # ℹ 1,966 more rows Se filtran los datos desde la fecha inicial y se crea una serie de tiempo. # Filtrar los datos para incluir solo las fechas desde octubre de 2021 dfdesc_filtrado &lt;- dfdesc[dfdesc$FECHA &gt;= as.Date(&quot;2018-01-01&quot;), ] # Crear la serie de tiempo usando la función &#39;ts&#39; dfts2 &lt;- ts(dfdesc_filtrado$NumeroNacidos, start = c(2018, 01), end = c(2020, 09), frequency = 12) # Imprimir la serie de tiempo print(dfts2) ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 2018 10 10 6 7 14 10 11 6 7 11 10 10 ## 2019 7 7 10 10 12 8 14 13 8 10 10 5 ## 2020 11 8 6 9 8 4 8 3 10 En este codigo se observa la descomposición aditiva la cual es un método que descompone una serie de tiempo en tres componentes principales: tendencia, estacionalidad y residuos. La tendencia representa la dirección general en la que se mueve la serie de tiempo a largo plazo. La estacionalidad representa los patrones repetitivos o cíclicos en la serie de tiempo que se repiten a intervalos regulares. Los residuos representan las fluctuaciones aleatorias o no sistemáticas que quedan una vez que se han eliminado la tendencia y la estacionalidad. library(forecast) ## Warning: package &#39;forecast&#39; was built under R version 4.2.3 ## Registered S3 method overwritten by &#39;quantmod&#39;: ## method from ## as.zoo.data.frame zoo library(ggplot2) ## Warning: package &#39;ggplot2&#39; was built under R version 4.2.3 descomposicion_aditiva&lt;-decompose(dfts2,type = &quot;additive&quot;) autoplot(descomposicion_aditiva,main=&quot;Descomposición Aditiva&quot;,xlab=&quot;Años/Meses&quot;) descomposicion_multiplicatica&lt;-decompose(dfts2,type = &quot;multiplicative&quot;) autoplot(descomposicion_multiplicatica,main=&quot;Descomposición Multiplicativa&quot;,xlab=&quot;Años/Meses&quot;) La diferencia principal entre la descomposición aditiva y la multiplicativa radica en cómo se modelan las tendencias y las estacionalidades en una serie de tiempo. Descomposición Aditiva: En este enfoque, se supone que los componentes de tendencia y estacionalidad se suman para formar la serie de tiempo original. La tendencia se modela como una función lineal o no lineal que cambia constantemente a lo largo del tiempo. La estacionalidad se modela como fluctuaciones fijas y constantes alrededor de la tendencia a lo largo del tiempo. La descomposición aditiva es apropiada cuando las variaciones en la serie de tiempo son aproximadamente constantes en magnitud a lo largo del tiempo. Descomposición Multiplicativa: En este enfoque, se supone que los componentes de tendencia y estacionalidad se multiplican para formar la serie de tiempo original. La tendencia se modela como una función multiplicativa que cambia a lo largo del tiempo. La estacionalidad se modela como fluctuaciones proporcionales a la tendencia a lo largo del tiempo. La descomposición multiplicativa es apropiada cuando las variaciones en la serie de tiempo cambian en magnitud a medida que el nivel de la serie de tiempo aumenta o disminuye. Cuando no hay diferencias significativas entre la descomposición aditiva y la multiplicativa, significa que ambos enfoques producen resultados similares y que la elección entre ellos no afectará significativamente la interpretación o el análisis de la serie de tiempo. Esto puede ocurrir en casos donde: La serie de tiempo exhibe patrones de variación relativamente simples y estables a lo largo del tiempo. La tendencia y la estacionalidad no interactúan de manera compleja entre sí. Los cambios en la serie de tiempo son consistentes y no muestran fluctuaciones inusuales o extremas. En la grafica se observa un leve patron estacional ts.plot(descomposicion_aditiva$seasonal,descomposicion_aditiva$random, col=c(&quot;blue&quot;,&quot;red&quot;)) title(main = &quot;Descomposición Aditiva: Componentes Estacionales y Aleatorios&quot;, line = 1) "],["Estacionalidad.html", "Chapter 4 Estacionalidad 4.1 Porcentaje de Estacionalidad por Mes y Año (2021-2024)", " Chapter 4 Estacionalidad La estacionalidad en un conjunto de datos se refiere a patrones recurrentes o fluctuaciones que ocurren en intervalos de tiempo regulares, como días, semanas, meses o años. Estos patrones pueden deberse a factores estacionales, como cambios climáticos, festividades, o comportamientos estacionales en la demanda de ciertos productos o servicios. La estacionalidad puede manifestarse de diferentes formas en los datos. Por ejemplo: Estacionalidad aditiva: En este caso, las fluctuaciones estacionales tienen una magnitud constante a lo largo del tiempo. Estacionalidad multiplicativa: Aquí, la magnitud de las fluctuaciones estacionales varía en función del nivel de la serie temporal. La identificación de la estacionalidad en un conjunto de datos es importante porque puede ayudarte a entender mejor las tendencias y los patrones subyacentes en tus datos. Además, puede ser útil para predecir futuros valores y tomar decisiones informadas, especialmente en industrias donde los patrones estacionales tienen un impacto significativo, como el comercio minorista, el turismo o la agricultura. library(readr) ## Warning: package &#39;readr&#39; was built under R version 4.2.3 # Leer el conjunto de datos desde el archivo CSV data &lt;- read_csv(&quot;data.csv&quot;, show_col_types = FALSE) # Convertir la columna fecha_nacimiento a formato de fecha data$fecha_nacimiento &lt;- as.Date(data$fecha_nacimiento) # Crear una nueva columna que contenga solo el año, mes y día data$fecha_nacimiento_nueva &lt;- format(data$fecha_nacimiento, &quot;%Y-%m-%d&quot;) head(data) ## # A tibble: 6 × 32 ## departamento municipio area_nacimiento sexo peso_gramos talla_cent_metros ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCU… 2085 45 ## 2 ANTIOQUIA ENVIGADO CABECERA MUNICIPAL FEMEN… 3000 47 ## 3 ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCU… 2905 50 ## 4 ANTIOQUIA ENVIGADO CABECERA MUNICIPAL FEMEN… 3700 50 ## 5 ANTIOQUIA ENVIGADO CABECERA MUNICIPAL FEMEN… 3130 49 ## 6 ANTIOQUIA ENVIGADO CABECERA MUNICIPAL MASCU… 3830 54 ## # ℹ 26 more variables: fecha_nacimiento &lt;date&gt;, tiempo_de_gestaci_n &lt;dbl&gt;, ## # n_mero_consultas_prenatales &lt;dbl&gt;, tipo_parto &lt;chr&gt;, ## # multiplicidad_embarazo &lt;chr&gt;, pertenencia_tnica &lt;chr&gt;, ## # grupo_indigena &lt;chr&gt;, edad_madre &lt;dbl&gt;, r_gimen_seguridad &lt;chr&gt;, ## # nombre_administradora &lt;chr&gt;, edad_padre &lt;dbl&gt;, nivel_educativo_padre &lt;chr&gt;, ## # departamento_expedici_n &lt;chr&gt;, municipio_expedici_n &lt;chr&gt;, ## # estado_conyugal_de_la_madre &lt;chr&gt;, nivel_educativo_de_la_madre &lt;chr&gt;, … library(ggplot2) # Convertir la columna fecha_nacimiento_nueva de caracteres a fecha data$fecha_nacimiento_nueva &lt;- as.Date(data$fecha_nacimiento_nueva) # Crear un histograma de las fechas de nacimiento ggplot(data, aes(x = fecha_nacimiento_nueva)) + geom_histogram(binwidth = 1, color = &quot;black&quot;, fill = &quot;blue&quot;) + labs(title = &quot;Distribución de fechas de nacimiento&quot;, x = &quot;Fecha de nacimiento&quot;, y = &quot;Frecuencia&quot;) library(lubridate) library(readr) library(dplyr) library(ggplot2) # Extraer el mes y el año de la fecha # Filtrar datos del año 2021 a 2022 data_filtrado &lt;- data %&gt;% filter(year(fecha_nacimiento) &gt;= 2021 &amp; year(fecha_nacimiento) &lt;= 2022) # Extraer el mes y el año de la fecha data_filtrado$mes &lt;- format(data_filtrado$fecha_nacimiento, &quot;%m&quot;) data_filtrado$año &lt;- format(data_filtrado$fecha_nacimiento, &quot;%Y&quot;) # Contar el número de casos por mes y año conteo_mes &lt;- data_filtrado %&gt;% group_by(mes) %&gt;% summarise(casos = n()) conteo_año &lt;- data_filtrado %&gt;% group_by(año) %&gt;% summarise(casos = n()) # Visualizar la estacionalidad a nivel mensual ggplot(conteo_mes, aes(x = mes, y = casos)) + geom_bar(stat = &quot;identity&quot;) + labs(title = &quot;Estacionalidad mensual (2021-2022)&quot;, x = &quot;Mes&quot;, y = &quot;Número de casos&quot;) library(plotly) # Contar el número de casos por mes y año conteo_mes_año &lt;- data_filtrado %&gt;% group_by(año, mes) %&gt;% summarise(casos = n()) # Convertir la columna &#39;año&#39; a factor para mantener el orden en el gráfico conteo_mes_año$año &lt;- factor(conteo_mes_año$año) # Crear gráfico interactivo de barras plot_ly(conteo_mes_año, x = ~mes, y = ~casos, color = ~año, type = &quot;bar&quot;) %&gt;% layout(title = &quot;Estacionalidad de mes por año (2021-2024)&quot;, xaxis = list(title = &quot;Mes&quot;), yaxis = list(title = &quot;Número de casos&quot;), colorway = c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;orange&quot;)) # Cambia los colores según sea necesario 4.1 Porcentaje de Estacionalidad por Mes y Año (2021-2024) La tabla a continuación muestra el porcentaje de estacionalidad por mes y año para el período comprendido entre 2021 y 2024. Estos datos representan la distribución relativa de casos a lo largo de los meses en cada año y proporcionan información sobre posibles patrones estacionales en la ocurrencia de eventos. Table 4.1: Porcentaje de estacionalidad por mes y año (2021-2024) año mes porcentaje 2021 10 35.8090186 2021 11 32.6259947 2021 12 31.5649867 2022 1 97.4683544 2022 2 0.4219409 2022 5 2.1097046 Estos datos revelan fluctuaciones significativas en la distribución de casos a lo largo de los meses, con algunos meses mostrando una concentración notable de casos, mientras que otros muestran una ocurrencia mínima. En el año 2022, por ejemplo, enero destaca con un porcentaje extremadamente alto de 97.47%, lo que sugiere una concentración significativa de casos en ese mes. Por otro lado, febrero muestra un porcentaje mínimo de 0.42%, indicando una ocurrencia muy baja de casos durante ese período. Mayo también muestra un pequeño aumento en la estacionalidad con un porcentaje del 2.11%, aunque sigue siendo relativamente bajo en comparación con otros meses. "],["HoltWinters.html", "Chapter 5 HoltWinters", " Chapter 5 HoltWinters El modelo Holt-Winters es una técnica de suavizamiento para análisis de series de tiempo que es especialmente útil cuando los datos exhiben tendencias y patrones estacionales. Este modelo es una extensión del método de suavizamiento exponencial de Holt, diseñado para capturar la estacionalidad además de la tendencia. Suavizamiento El suavizamiento significa hacer los datos más regulares o uniformes, eliminando las fluctuaciones aleatorias y destacando tendencias o patrones importantes. El modelo utiliza fórmulas para combinar de manera ponderada estos tres componentes, ajustando los pesos (llamados parámetros de suavizamiento) para que se adapten de la mejor manera a los datos históricos. Predicción Para hacer predicciones, el modelo usa los valores estimados de nivel, tendencia y estacionalidad, proyectándolos hacia adelante. Esto es útil para planificar y tomar decisiones basadas en lo que se espera que ocurra en el futuro, considerando patrones pasados. Recordemos nuevamente nuestros datos: 5.0.1 Nuestros datos. Validamos si nuestros datos son estacionarios: ## ## Augmented Dickey-Fuller Test ## ## data: serie_temporal ## Dickey-Fuller = -3.3185, Lag order = 5, p-value = 0.07122 ## alternative hypothesis: stationary Dado que el valor p es menor que un nivel de significancia común, como 0.05, hay evidencia suficiente para rechazar la hipótesis nula de que la serie temporal es no estacionaria. Por lo tanto, en este caso, podemos concluir que la serie temporal es estacionaria. Ahora utilizaremos la funcion descompose para ver la descomposicion de nuestra serie de tiempo en tres observaciones fundamentales como son Trend, seasonal y random. (despues del grafico se explica cada una). Tendencia (Trend): La tendencia describe la dirección general en la que los datos cambian con el tiempo. En el contexto del modelo Holt-Winters, esta tendencia se identifica y se incorpora para realizar pronósticos futuros. En nuestra serie temporal, observamos fluctuaciones notables en la tendencia a lo largo de los años. Por ejemplo, a principios de 2019, la tendencia muestra una marcada disminución, seguida de un repunte hacia mediados de 2020 y posteriormente, una nueva caída. Sin embargo, a partir de 2022, la tendencia muestra un claro aumento en el número de nacimientos vivos, lo que sugiere una tendencia alcista continua. Estacionalidad (Seasonal): En el método Holt-Winters, la estacionalidad representa los patrones recurrentes que se presentan en los datos a intervalos regulares. El modelo detecta y pronostica estas fluctuaciones estacionales para mejorar la precisión de las predicciones. En relación con nuestra serie temporal, la prueba de Dickey-Fuller arrojó un valor por debajo de 0.05, lo que sugiere que nuestra serie de tiempo es estacionaria. Este resultado refuerza la confiabilidad en el modelo al identificar y prever adecuadamente las variaciones estacionales en los datos. Componente aleatorio (Random): El componente aleatorio en Holt-Winters representa la variación no sistemática o aleatoria en los datos que no puede ser explicada por la tendencia o la estacionalidad. El modelo intenta capturar este componente para mejorar la precisión de los pronósticos, notamos un fuerte ruido en los datos para nuestros valores aleatorios. 5.0.2 Aplicando Holt-Winters. A tener en cuenta los parametros de suavizados del modelo Holt-Winters. alpha: Este parámetro controla el suavizado exponencial para la estimación de la componente de nivel (nivel base) en el modelo. Indica cuánto peso se le da a las observaciones pasadas para predecir el nivel actual. Un valor más cercano a 1 significa que se da más peso a las observaciones pasadas, lo que resulta en una adaptación más lenta a los cambios. beta: Este parámetro controla el suavizado exponencial para la estimación de la componente de tendencia en el modelo. Indica cuánto peso se le da a las observaciones pasadas para predecir la tendencia actual. Al igual que alpha, un valor más cercano a 1 significa que se da más peso a las observaciones pasadas. gamma: Este parámetro controla el suavizado exponencial para la estimación de la componente estacional en el modelo. Indica cuánto peso se le da a las observaciones pasadas para predecir la estacionalidad actual. Al igual que con alpha y beta, un valor más cercano a 1 significa que se da más peso a las observaciones pasadas. Existen dos formas de aplicar el modelo Holt-Winters: 1. Método Holt-Winters aditivo: En el método aditivo, la estacionalidad se agrega a la serie temporal. La tendencia y la estacionalidad se suman al nivel base para obtener los valores observados. Es más adecuado cuando la magnitud de la estacionalidad no cambia en proporción al nivel de la serie temporal. En otras palabras, la estacionalidad no crece o disminuye con el nivel de los datos. ahora aplicaremos nuestro modelo Holt-winter additive a nuestra serie de tiempo en el siguiente segmento de codigo: HW_additive &lt;- HoltWinters(dfts3, seasonal = &quot;additive&quot;) paste(&quot;alpha &quot;,HW_additive$alpha, &quot; beta&quot;,HW_additive$beta,&quot; gamma&quot;, HW_additive$gamma) ## [1] &quot;alpha 0.24610451750226 beta 0.00257109348712916 gamma 0.375739470223313&quot; En la salida observamos como aplicamos nuestro modelo y tambien podria observar el valor de cada uno de nuestros coeficientes, pero en este caso solo nos interesan nuestros parametros de suavisado, a continuación se explicaran: alpha: es de 0.24610451750226 nuestro modelo alpha tiene un valor bajo, esto quiere decir que no se le da un mayor peso a las observaciones pasadas. beta: 0.00257109348712916 este valor es muy bajo lo que quiere decir que el modelo casi que no tiene en cuenta la tendencia actual. gamma: 0.375739470223313 este valor esta mas cercano a 1 que los anteriores lo cual lo consideramos como valor moderado, el cual otorga peso a las observaciones pasadas y recientes en la estimación de la estacionalidad actual. Veamos el comportamiento de nuestro modelo Holt-Winters aditivo En general, el modelo demuestra eficacia en la predicción de valores promedio. Sin embargo, muestra debilidad al enfrentarse a cambios abruptos en la tendencia. Específicamente, el modelo Holt-Winters aditivo no logra anticipar estos cambios. A pesar de ello, procederemos a realizar pronósticos para los próximos 24 meses utilizando este modelo. Reafirmamos el anterior parrafo: “En general, el modelo demuestra eficacia en la predicción de valores promedio. Sin embargo, muestra debilidad al enfrentarse a cambios abruptos en la tendencia. Específicamente, el modelo Holt-Winters aditivo no logra anticipar estos cambios.” cuando intentamos pronosticar los proximos 24 meses, vemos como nuestro modelo se apega demasiado a nuestros valores promedios. 2. Método Holt-Winters multiplicativo: El Método Holt-Winters multiplicativo es un enfoque de suavización exponencial utilizado en análisis de series temporales para predecir valores futuros. Este método es una extensión del método de suavización exponencial simple, que toma en cuenta tendencias y estacionalidad en los datos. En lugar de tratar estas componentes como aditivas, como se hace en el Método Holt-Winters aditivo, el Método Holt-Winters multiplicativo las considera como multiplicativas. Esto significa que tanto la tendencia como la estacionalidad se aplican multiplicativamente a los niveles de la serie temporal en lugar de sumarse directamente En el método multiplicativo, la estacionalidad se multiplica por la serie temporal. La tendencia y la estacionalidad se multiplican al nivel base para obtener los valores observados. Es más apropiado cuando la magnitud de la estacionalidad varía en proporción al nivel de la serie temporal. En este caso, la estacionalidad aumenta o disminuye en relación con el nivel de los datos. ahora aplicaremos nuestro modelo Holt-winter multiplicativo a nuestra serie de tiempo en el siguiente segmento de codigo: ## [1] &quot;alpha 0.026371845082938 beta 0.0619052437826439 gamma 0.323835874454532&quot; alpha: es de 0.026371845082938 nuestro modelo alpha tiene un valor bajo, esto quiere decir que no se le da un mayor peso a las observaciones pasadas, es un poco mas alta que el modelo aditivo. beta: 0.0619052437826439 este valor es muy bajo lo que quiere decir que el modelo casi no tiene en cuenta la tendencia actual, pero es mucho mas alto que el modelo aditivo. gamma: 0.323835874454532 este valor esta mas cercano a 1 que los anteriores lo cual lo consideramos como valor moderado, el cual otorga peso a las observaciones pasadas y recientes en la estimación de la estacionalidad actual, este valor es el unico que esta por debo con respecto al modelo aditivo. Veamos el comportamiento de nuestro modelo Holt-Winters multiplicativo En general, el modelo Holt-Winters multiplicativo demuestra eficacia en la predicción de valores promedio. Sin embargo, muestra debilidad al enfrentarse a cambios abruptos en la tendencia, siendo menos capaz de anticipar estos cambios que su contraparte aditiva. Además, en muchos picos tiende a disminuir el número de nacidos vivos, lo que sugiere que es más conservador en sus predicciones que el modelo aditivo. A pesar de ello, procederemos a realizar pronósticos para los próximos 24 meses utilizando este modelo. Reafirmamos el anterior parrafo: En general, el modelo Holt-Winters multiplicativo demuestra eficacia en la predicción de valores promedio. Sin embargo, muestra debilidad al enfrentarse a cambios abruptos en la tendencia, siendo menos capaz de anticipar estos cambios que su contraparte aditiva. Además, en muchos picos tiende a disminuir el número de nacidos vivos, lo que sugiere que es más conservador en sus predicciones que el modelo aditivo. ” cuando intentamos pronosticar los proximos 24 meses, vemos como nuestro modelo se apega demasiado a nuestros valores promedios, al igual que el modelo Holt-Winters Aditivo. 5.0.3 Conclusiones Holt-Winters. Cuando intentamos pronosticar los próximos 24 meses, observamos cómo nuestro modelo Holt-Winters multiplicativo se adhiere demasiado a los valores promedio, al igual que el modelo Holt-Winters aditivo. En general, ambos modelos demuestran eficacia en la predicción de valores promedio. Sin embargo, muestran debilidad al enfrentarse a cambios abruptos en la tendencia. Específicamente, el modelo Holt-Winters multiplicativo tiende a ser más conservador en sus predicciones, mientras que el modelo aditivo puede subestimar o sobreestimar estos cambios. Aunque ambos modelos son útiles para predecir valores promedio, es importante tener en cuenta sus limitaciones al enfrentarse a cambios repentinos en la tendencia. Es posible que se necesiten ajustes adicionales o considerar otros métodos de pronóstico para mejorar la capacidad de anticipar estos cambios, tambien podriamos hacer un hiper parametros tuning para tomar los mejores parametros para nuestros modelos. "],["PromedioMovil..html", "Chapter 6 Promedio Movil. 6.1 Análisis de nuestro DataFrame.", " Chapter 6 Promedio Movil. El promedio móvil es una técnica utilizada en análisis de series temporales para suavizar las fluctuaciones a corto plazo y resaltar tendencias o patrones a largo plazo. Consiste en calcular la media de un conjunto de valores adyacentes en una serie temporal y usar ese valor promedio como una estimación del valor en el punto medio de esos valores. Existen dos tipos de promedio movil: Promedio Movil Simple SMA: Suaviza los datos históricos calculando el promedio de los últimos periodos y proyectando este promedio hacia adelante. Este método es ideal para datos volátiles sin tendencia ni estacionalidad. El resultado es una previsión plana y constante. Forumula: \\[ SMA = \\frac{{X_1 + X_2 + X_3 + \\ldots + X_n}}{{n}} \\] Donde: - \\(X_1, X_2, X_3, \\ldots, X_n\\) son los valores de la serie de tiempo. - \\(n\\) es el número total de valores en la serie de tiempo. Promedio Movil Exponencial EMA: Similar al SMA, pero asigna pesos diferentes a las observaciones en la ventana de tiempo. Las observaciones más recientes suelen tener un peso más alto que las observaciones más antiguas. Forumula: \\[ EMA(t) = (1 - \\alpha) \\times EMA(t - 1) + \\alpha \\times X(t) \\] Donde: - \\[EMA(t)\\] es el promedio móvil exponencial en el tiempo . - \\[X(t)\\] es el valor de la serie temporal en el tiempo . - \\[α\\] es el factor de suavizado, que controla la tasa de decrecimiento de los pesos exponenciales. Normalmente se elige entre 0 y 1, donde valores más cercanos a 1 otorgan más peso a las observaciones más recientes. 6.1 Análisis de nuestro DataFrame. Aunque nuestro DataFrame tenga el campo de fecha y hora, para el análisis de los promedios móviles solo tomaremos la suma de los nacidos vivos por fecha. Teniendo en cuenta la variable MULTIPLICIDAD.EMBARAZO, que solo cuenta con dos tipos: simples y dobles. Es importante entender que si en la fecha 2018-01-01 hubo un parto doble, entonces el número de nacidos es igual a dos y cuando es simple el numero de nacidos solo es uno. 6.1.1 BoxPlot Nacidos por año. El gráfico de boxplot es muy revelador, ya que nos muestra claramente que mientras la mediana para el año 2018 es de 9 y para el año 2019 es de 10, podría suponerse que la mediana para el 2020 sería mayor a 10. Sin embargo, esto no fue así, ya que el año 2020 fue atípico para todos los sectores, incluido el sector de la salud. Observamos que el año 2020 marcó una tendencia crucial y significativa en la mediana, ya que desde entonces hasta el año 2023, la mediana no ha experimentado grandes cambios y siempre ha permanecido alrededor de 7. 6.1.2 Numero de Nacidos por fecha. En el boxplot anterior, podemos observar claramente la tendencia general de los datos, así como los valores atípicos. Por ejemplo, a finales de 2018, observamos nuestro primer pico en el número de nacimientos vivos por día, seguido de una tendencia estable en 2019. Sin embargo, en 2020 notamos una disminución en los nacimientos vivos, y hacia finales de ese mismo año, se destaca un pico máximo en nuestros datos. Para los años posteriores, la tendencia se mantiene estable. Identificamos valores atípicos entre mediados de 2022 y 2023, probablemente debido a la falta de datos entre junio de 2022 y enero de 2023. Sin embargo, el resto de los años sigue una tendencia normal. Es aquí donde entra a ayudar el método de promedio móvil simple y promedio móvil ponderado. Estos métodos nos permiten suavizar los datos y detectar mejor las tendencias a lo largo del tiempo, especialmente cuando se enfrenta a datos con valores atípicos o fluctuaciones irregulares. 6.1.3 Ejemplo: Promedio Movil Simple SMA: Transformando nuestros datos a zoo y aplicando la función rollmean con k 7,15,30 GraficoShiny_2 &lt;- as.data.frame(GraficoShiny_2) datos_zoo &lt;- zoo(GraficoShiny_2$NumeroNacidos, order.by = GraficoShiny_2$FECHA) promedio_movil_7 &lt;- rollmean(datos_zoo, k = 7, align = &quot;right&quot;, fill = NA) promedio_movil_15 &lt;- rollmean(datos_zoo, k = 15, align = &quot;right&quot;, fill = NA) promedio_movil_30 &lt;- rollmean(datos_zoo, k = 30, align = &quot;right&quot;, fill = NA) DatosPromedioMovil &lt;- cbind(GraficoShiny_2, PromedioMovil_7 = promedio_movil_7) DatosPromedioMovil &lt;- cbind(DatosPromedioMovil, PromedioMovil_15 = promedio_movil_15) DatosPromedioMovil &lt;- cbind(DatosPromedioMovil, PromedioMovil_30 = promedio_movil_30) Graficando nuestros datos DatosPromedioMovil DatosPromedioMovil$FECHA &lt;- as.Date(DatosPromedioMovil$FECHA) plot_ly(data = DatosPromedioMovil, x = ~FECHA) %&gt;% add_lines(y = ~NumeroNacidos, name = &quot;NumeroNacidos&quot;, line = list(color = &quot;orange&quot;)) %&gt;% add_lines(y = ~PromedioMovil_7, name = &quot;PromedioMovil 7&quot;, line = list(color = &quot;red&quot;)) %&gt;% add_lines(y = ~PromedioMovil_15, name = &quot;PromedioMovil 15&quot;, line = list(color = &quot;green&quot;)) %&gt;% add_lines(y = ~PromedioMovil_30, name = &quot;PromedioMovil 30&quot;, line = list(color = &quot;blue&quot;)) %&gt;% layout(title = &quot;Promedio Movil Simple&quot;, xaxis = list(title = &quot;Fecha&quot;), yaxis = list(title = &quot;Numero de nacidos&quot;), legend = list(orientation = &quot;h&quot;, y = 1, yanchor = &quot;bottom&quot;, x = 0.5, xanchor = &quot;center&quot;)) Como indica la leyenda de la gráfica anterior, los datos reales se muestran en amarillo, seguidos por los promedios móviles simples calculados. Se destaca que el promedio móvil simple de 7 días, resaltado en rojo, sigue de cerca la tendencia de los datos reales. Por otro lado, el promedio móvil de 15 días muestra una mayor suavización en comparación con los datos reales, mientras que el de 30 días exhibe una tendencia más estable con menos fluctuaciones, cumpliendo así el propósito del SMA de suavizar la tendencia. 6.1.4 Ejemplo: Promedio Movil Exponencial EMA: Aplicando la función EMA con n 7,15,30 promedio_movil_7 &lt;- EMA(GraficoShiny_2$NumeroNacidos, n = 7) promedio_movil_15 &lt;- EMA(GraficoShiny_2$NumeroNacidos, n = 15) promedio_movil_30 &lt;- EMA(GraficoShiny_2$NumeroNacidos, n = 30) DatosPromedioMovilEma &lt;- cbind(GraficoShiny_2, PromedioMovil_7 = promedio_movil_7) DatosPromedioMovilEma &lt;- cbind(DatosPromedioMovilEma, PromedioMovil_15 = promedio_movil_15) DatosPromedioMovilEma &lt;- cbind(DatosPromedioMovilEma, PromedioMovil_30 = promedio_movil_30) Graficando nuestros datos DatosPromedioMovilEma DatosPromedioMovilEma$FECHA &lt;- as.Date(DatosPromedioMovilEma$FECHA) plot_ly(data = DatosPromedioMovilEma, x = ~FECHA) %&gt;% add_lines(y = ~NumeroNacidos, name = &quot;NumeroNacidos&quot;, line = list(color = &quot;orange&quot;)) %&gt;% add_lines(y = ~PromedioMovil_7, name = &quot;PromedioMovil 7&quot;, line = list(color = &quot;red&quot;)) %&gt;% add_lines(y = ~PromedioMovil_15, name = &quot;PromedioMovil 15&quot;, line = list(color = &quot;green&quot;)) %&gt;% add_lines(y = ~PromedioMovil_30, name = &quot;PromedioMovil 30&quot;, line = list(color = &quot;blue&quot;)) %&gt;% layout(title = &quot;Promedio Movil Exponencial&quot;, xaxis = list(title = &quot;Fecha&quot;), yaxis = list(title = &quot;Numero de nacidos&quot;), legend = list(orientation = &quot;h&quot;, y = 1, yanchor = &quot;bottom&quot;, x = 0.5, xanchor = &quot;center&quot;)) El Promedio Móvil Exponencial (EMA) guarda similitudes con el Promedio Móvil Simple, aunque difiere en que el EMA otorga mayor importancia o peso a los valores más recientes. Esta diferencia radica en la manera en que se calcula, dando lugar a una respuesta más rápida a los cambios en los datos. Como resultado, la tendencia del EMA, como se muestra en la gráfica anterior, se asemeja a la del promedio móvil simple previo. Sin embargo, debido a su enfoque en los datos más recientes, el EMA puede capturar de manera más efectiva las tendencias emergentes o los cambios recientes en el comportamiento de los datos. 6.1.5 Conclusiones: tanto el Promedio Móvil Simple (SMA) como el Promedio Móvil Exponencial (EMA) son herramientas efectivas para suavizar las fluctuaciones de los datos y destacar tendencias. Mientras que el SMA se enfoca en ofrecer una visión general de la tendencia, el EMA prioriza los datos más recientes, lo que le permite adaptarse rápidamente a los cambios en el comportamiento de los datos. Ambos enfoques son valiosos según el contexto y el objetivo del análisis. "],["Rezagos.html", "Chapter 7 Rezagos", " Chapter 7 Rezagos Los rezagos se usan para evaluar los valores de un conjunto de datos o una serie de tiempo y saber si es aleatoria o no. Si los datos son aleatorios las graficas no mostraran un comportamiento identificable y si los datos no son aleatorios, las graficas mostraran un comportamiento identificable. Los rezagos tambien ayudan a identificar outliers. Preparación de los datos Este código carga datos de nacimientos y los agrupa para calcular el número total de nacidos vivos por fecha teniendo en cuenta los partos dobles o simples. library(readr) library(dplyr) DatosNacidos &lt;- read.csv(file = &quot;data/Nacidos_Vivos_en_Hospital_Manuel_Uribe_Angel_20240418.csv&quot;) DatosNacidos$FECHA &lt;- substr(DatosNacidos$FECHA,1,10) DatosNacidos$FECHA &lt;- as.Date(DatosNacidos$FECHA, format = &quot;%m/%d/%Y&quot;) agrupnacidos &lt;- DatosNacidos %&gt;% group_by(FECHA, MULTIPLICIDAD.EMBARAZO) %&gt;% summarize(NumeroPartos = n(), .groups = &#39;drop&#39;) agrupnacidos$NumeroNacidos &lt;- ifelse(agrupnacidos$MULTIPLICIDAD.EMBARAZO == &quot;DOBLE&quot;,agrupnacidos$NumeroPartos*2,agrupnacidos$NumeroPartos) agrupnacidos_2 &lt;- agrupnacidos %&gt;% group_by(FECHA) %&gt;% summarize(NumeroNacidos=sum(NumeroNacidos), .groups = &#39;drop&#39;) df &lt;- agrupnacidos_2 Este código crea un histograma que muestra la distribución de las fechas de nacimiento en el conjunto de datos df. Cada barra en el histograma representa el número de personas nacidas en un año específico. library(ggplot2) ggplot(df, aes(x = FECHA )) + geom_histogram(binwidth = 360) + # Establecemos el ancho de las barras en 1 mes (30 días) labs(title = &quot;Distribucion de fechas de nacimiento&quot;, x = &quot;Fecha de nacimiento&quot;, y = &quot;Frecuencia&quot;) Este código filtra y resume los datos de nacimientos para un período específico, luego crea una serie de tiempo a partir de estos datos y la imprime para su visualización. library(forecast) library(tseries) library(timsac) ## Warning: package &#39;timsac&#39; was built under R version 4.2.3 library(changepoint) ## Warning: package &#39;changepoint&#39; was built under R version 4.2.3 ## Successfully loaded changepoint package version 2.2.4 ## See NEWS for details of changes. if (!requireNamespace(&quot;lubridate&quot;, quietly = TRUE)) { install.packages(&quot;lubridate&quot;) } library(lubridate) # Crear un nuevo DatosNacidos con las fechas filtradas y la suma de nacidos vivos por día df_resumen &lt;- df %&gt;% filter(FECHA &gt;= as.Date(&quot;2021-10-01&quot;) &amp; FECHA &lt;= as.Date(&quot;2022-02-01&quot;)) %&gt;% mutate(day = as.Date(FECHA )) %&gt;% group_by(day) %&gt;% summarise(total_nacidos_vivos = sum(NumeroNacidos)) # Convertir el DatosNacidos resumido en una serie de tiempo usando la función &#39;ts&#39; dfts &lt;- ts(df_resumen$total_nacidos_vivos, start = c(2021, 10), end = c(2022, 2), frequency = 365) # Imprimir la serie de tiempo print(dfts) ## Time Series: ## Start = c(2021, 10) ## End = c(2022, 2) ## Frequency = 365 ## [1] 16 9 5 10 12 2 5 10 6 11 3 5 16 9 8 7 10 8 13 9 4 11 7 17 10 ## [26] 7 5 10 8 11 12 6 5 12 7 7 9 6 8 7 12 3 5 8 11 9 6 11 13 11 ## [51] 9 4 13 14 10 7 6 5 6 12 8 13 5 8 8 7 10 6 4 9 12 9 11 5 7 ## [76] 9 13 6 7 11 2 5 5 7 7 7 7 9 8 9 7 7 13 8 10 3 7 10 8 9 ## [101] 7 5 10 8 8 5 5 13 7 10 10 6 12 3 2 6 14 7 6 7 3 12 9 8 16 ## [126] 9 5 10 12 2 5 10 6 11 3 5 16 9 8 7 10 8 13 9 4 11 7 17 10 7 ## [151] 5 10 8 11 12 6 5 12 7 7 9 6 8 7 12 3 5 8 11 9 6 11 13 11 9 ## [176] 4 13 14 10 7 6 5 6 12 8 13 5 8 8 7 10 6 4 9 12 9 11 5 7 9 ## [201] 13 6 7 11 2 5 5 7 7 7 7 9 8 9 7 7 13 8 10 3 7 10 8 9 7 ## [226] 5 10 8 8 5 5 13 7 10 10 6 12 3 2 6 14 7 6 7 3 12 9 8 16 9 ## [251] 5 10 12 2 5 10 6 11 3 5 16 9 8 7 10 8 13 9 4 11 7 17 10 7 5 ## [276] 10 8 11 12 6 5 12 7 7 9 6 8 7 12 3 5 8 11 9 6 11 13 11 9 4 ## [301] 13 14 10 7 6 5 6 12 8 13 5 8 8 7 10 6 4 9 12 9 11 5 7 9 13 ## [326] 6 7 11 2 5 5 7 7 7 7 9 8 9 7 7 13 8 10 3 7 10 8 9 7 5 ## [351] 10 8 8 5 5 13 7 10 Este código traza una serie de tiempo en un gráfico, donde el eje x representa los años y el eje y representa los valores de la serie de tiempo. plot(dfts, main= &quot; &quot;, ylab=&quot;valor&quot;, col=&quot;deepskyblue&quot;, xlab=&quot;Años&quot;) Este codigo se utiliza para obtener la fecha de inicio y la fecha de finalización de la serie de tiempo. start(dfts) ## [1] 2021 10 end(dfts) ## [1] 2022 2 El gráfico de rezagos muestra la relación entre los valores de la serie de tiempo en un período de tiempo y los valores de la misma serie de tiempo en períodos de tiempo anteriores (rezagos)en este caso se tomaron 9 periodos o rezagos. Este analisis ayuda a identificar la autocorrelación en los datos, es decir, si los valores de la serie de tiempo están correlacionados consigo mismos en el tiempo. Esto puede ser útil para diagnosticar si hay patrones temporales en los datos. En la grafica no se observa un comportamiento identificable, es posible que los datos sean aleatorios. Como el comportamiento no se repite entre estas distancias esto puede inferir que no existe estacionalidad. lag.plot(dfts, 9, do.lines = FALSE) Este codigo crea un gráfico que muestra la serie de tiempo original y sus rezagos, lo que permite visualizar cómo los valores de la serie de tiempo están correlacionados con sus valores pasados. # Crear un data frame con la serie original y sus rezagos df_lags &lt;- data.frame( tiempo = time(dfts), nacidos_vivos = dfts, lag1 = stats::lag(dfts, 1), lag2 = stats::lag(dfts, 2), lag3 = stats::lag(dfts, 3) ) ggplot(df_lags, aes(x = tiempo)) + geom_point(aes(y = nacidos_vivos, color = &quot;Original&quot;), size = 3, position = position_jitter(width = 0.2)) + geom_point(aes(y = lag1, color = &quot;Lag 1&quot;), shape = 1, size = 2, position = position_jitter(width = 0.2)) + labs(title = &quot;Serie de tiempo y sus rezagos&quot;, x = &quot;Tiempo&quot;, y = &quot;Valor&quot;) + scale_color_manual(values = c(&quot;Original&quot; = &quot;blue&quot;, &quot;Lag 1&quot; = &quot;red&quot;, &quot;Lag 2&quot; = &quot;green&quot;, &quot;Lag 3&quot; = &quot;purple&quot;)) + theme_minimal() ## Don&#39;t know how to automatically pick scale for object of type ## &lt;ts&gt;. Defaulting to continuous. ## Don&#39;t know how to automatically pick scale for object of type ## &lt;ts&gt;. Defaulting to continuous. "]]
